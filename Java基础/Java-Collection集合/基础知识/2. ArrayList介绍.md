<!-- GFM-TOC -->
* [ArrayList介绍](#arraylist介绍)
    * [1. ArrayList 简介](#1-arraylist-简介)
       * [1.1 实现细节](#11-实现细节)
         * [1.1.1 实现和继承关系](#111-实现和继承关系) 
         * [1.1.2 底层实现](#112-底层实现)
           * [1.1.2.1 transient关键字](#1121-transient关键字)
           * [1.1.2.2 构造器](#1122-构造器)
           * [1.1.2.3 扩容机制](#1123-扩容机制)
    * [2. ArrayList高级特性](#2-arraylist高级特性)
      * [2.1 线程不安全](#21-线程不安全)
         * [2.1.1 解决方案](#211-解决方案)
      * [2.2 fail-fast问题](#22-fail-fast问题)
   
<!-- GFM-TOC -->
# ArrayList介绍
## 1. ArrayList 简介
```
   ArrayList 是一个数组队列,动态数组(动态扩容); 允许添加null元素;
```
### 1.1 实现细节
```
  public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```
#### 1.1.1 实现和继承关系
   - **继承** 抽象类**AbstractList**,实现了List;List是一个数组队列,提供了相关的添加,删除,修改,遍历等功能;
   - **实现** RandomAccess接口,即提供了随机访问功能;RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。
   - **实现** Cloneable接口,即覆盖了clone()方法,能被克隆;
   - **实现** java.io.Serializable 接口,支持序列化,能通过序列化去传输;
  
#### 1.1.2 底层实现
```
    transient Object[] elementData; // non-private to simplify nested class access
```
 - 实质上是 **Object数组** 构成;
##### 1.1.2.1 transient关键字
   - 为何会有transient关键字,何时会用到它?
   ```
     一个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。
   ```
   - transient 关键字使用总结</br>
    [transient博文](https://www.cnblogs.com/lanxuezaipiao/p/3369962.html#top)</br>
    [深入学习序列化](http://mp.weixin.qq.com/s/MGCwOELDN8lIlvfTwhPAbQ)
##### 1.1.2.2 构造器
 - 空构造器
   - 默认初始化容量:10
```
   /**
     * Default initial capacity.
     */
    private static final int DEFAULT_CAPACITY = 10;
```
```
 /**
     * Constructs an empty list with an initial capacity of ten.
     */
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
```
   - **不同之处**
 ```
   JDK 1.7和JDK1.8默认构造器发生了变化,但是默认初始化容量都是10;具体实现,暂不深究;
 ```
  - int 参数构造器
    - 参数为一个int 整数; 
```
   /**
     * 给定一个容量,然后创建相对应大小的Objec[]数组;
     *
     * Constructs an empty list with the specified initial capacity.
     *
     * @param  initialCapacity  the initial capacity of the list
     * @throws IllegalArgumentException if the specified initial capacity
     *         is negative
     */
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }
```
 - 集合参数构造器
   - 参数为Collection集合下具体实现类;
```
  /**
     * Constructs a list containing the elements of the specified
     * collection, in the order they are returned by the collection's
     * iterator.
     *
     * @param c the collection whose elements are to be placed into this list
     * @throws NullPointerException if the specified collection is null
     */
    public ArrayList(Collection<? extends E> c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
    举栗子说明:
     LinkedList<Object> linkedList = new LinkedList<>();
        linkedList.add(1);
        linkedList.add(2);
        linkedList.add(3);
        ArrayList<Object> objects = new ArrayList<>(linkedList);
        for (Object object : objects) {
            System.out.println(object);
        }
    // 1 2 3
```
##### 1.1.2.3 扩容机制
 - 扩容变化:
   - 每次扩容 50% , 亦新容量为旧容量的1.5倍
```
  思考下,什么时候会扩容? 肯定是装不下东西的时候会扩容哦,所以我们从添加元素 方法开始;
```
 **[1]** add 方法 
   - add(E e)方法, 默认添加到尾部

```
 [1] add方法添加元素
  public boolean add(E e) {
        //在添加元素前调用ensureCapacityInternal方法,进行容量检验,看能否装得下;
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
    
 [2] ensureCapacityInternal检验容量
  private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }
    
 [3]实质检验方法 ensureExplicitCapacity
 private void ensureExplicitCapacity(int minCapacity) {
        // modCount 用来记录 ArrayList 结构发生变化的次数，因为每次在进行 add() 和 addAll() 时都需要调用 ensureCapacity()，因此直接在 ensureExplicitCapacity()中对 modCount 进行修改
        modCount++;
        // overflow-conscious code
        // 看下
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
  [4]校验完毕之后,进入到扩容grow()方法中
   /**
     * Increases the capacity to ensure that it can hold at least the
     * number of elements specified by the minimum capacity argument.
     *
     * @param minCapacity the desired minimum capacity
     */
    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        // 新容量是旧容量的1.5倍,即扩容 50%;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```
 - add(int index,E element) 在特定位置插入元素
```
  System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
  具体代码不贴入,关键点在于当一个元素被插入后,之后的元素都会被整体后移一个单位长度,会涉及到整体复制,性能消耗大,这也是和LinkedList最本质的区别;
  ArrayList查询便捷,LinkedList删除便捷;
```
## 2. ArrayList高级特性
### 2.1 线程不安全
```
  ArrayList是不安全的,我们举一个例子说明下:
  //添加元素源码
  public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
  一个 ArrayList 在添加一个元素的时候，它可能会有两步来完成:
  1.在elementData[size]的位置上存放此元素;
  2.增大size的值;
  其本质上来讲是size++不是一个原子操作导致的线程安全问题;
  [1]在单线程环境下,如果size=0,添加一个元素后,此元素在位置0,而且size=1;
  [2]在多线程环境下,比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。
    线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0（注意哦，我们假设的是添加一个元素是要两个步骤哦，
    而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。
    然后线程A和线程B都继续运行，都增加 Size 的值; 
```
#### 2.1.1 解决方案
 - 使用synchronized关键字,锁定临界区;
 - 使用 **Collections.synchronizedList()**,使用方法如下:
```
  
```
 - 使用JUC中的 CopyOnWriteArrayList
```
  具体的使用之后会在多线程模块中具体分析并发容器的数据结构;
```
### 2.2 fail-fast问题
#### 2.2.1 简介
```
  fail-fast 机制是java集合(Collection)中的一种错误机制,当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。
例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。
```
[fast-fail博文](http://wangkuiwu.github.io/2012/02/04/collection-04-fail-fast/)
   
  
  



    
