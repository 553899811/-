<!-- GFM-TOC -->
* [ArrayList介绍](#arraylist介绍)
    * [1. ArrayList 简介](#1-arraylist-简介)
       * [1.1 实现细节](#11-实现细节)
         * [1.1.1 实现和继承关系](#111-实现和继承关系) 
         * [1.1.2 底层实现](#112-底层实现)
           * [1.1.2.1 transient关键字](#1121-transient关键字)
           * [1.1.2.2 构造器](#1122-构造器)
           * [1.1.2.3 扩容机制](#1123-扩容机制)
   
<!-- GFM-TOC -->
# ArrayList介绍
## 1. ArrayList 简介
```
   ArrayList 是一个数组队列,动态数组(动态扩容); 允许添加null元素;
```
### 1.1 实现细节
```
  public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```
#### 1.1.1 实现和继承关系
   - **继承** 抽象类**AbstractList**,实现了List;List是一个数组队列,提供了相关的添加,删除,修改,遍历等功能;
   - **实现** RandomAccess接口,即提供了随机访问功能;RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。
   - **实现** Cloneable接口,即覆盖了clone()方法,能被克隆;
   - **实现** java.io.Serializable 接口,支持序列化,能通过序列化去传输;
  
#### 1.1.2 底层实现
```
    transient Object[] elementData; // non-private to simplify nested class access
```
 - 实质上是 **Object数组** 构成;
##### 1.1.2.1 transient关键字
   - 为何会有transient关键字,何时会用到它?
   ```
     一个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。
   ```
   - transient 关键字使用总结</br>
    [推荐博文](https://www.cnblogs.com/lanxuezaipiao/p/3369962.html#top)
##### 1.1.2.2 构造器
 - 空构造器
   - 默认初始化容量:10
```
   /**
     * Default initial capacity.
     */
    private static final int DEFAULT_CAPACITY = 10;
```
```
 /**
     * Constructs an empty list with an initial capacity of ten.
     */
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
```
   - **不同之处**
 ```
   JDK 1.7和JDK1.8默认构造器发生了变化,但是默认初始化容量都是10;具体实现,暂不深究;
 ```
  - int 参数构造器
    - 参数为一个int 整数; 
```
   /**
     * 给定一个容量,然后创建相对应大小的Objec[]数组;
     *
     * Constructs an empty list with the specified initial capacity.
     *
     * @param  initialCapacity  the initial capacity of the list
     * @throws IllegalArgumentException if the specified initial capacity
     *         is negative
     */
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }
```
 - 集合参数构造器
   - 参数为Collection集合下具体实现类;
```
  /**
     * Constructs a list containing the elements of the specified
     * collection, in the order they are returned by the collection's
     * iterator.
     *
     * @param c the collection whose elements are to be placed into this list
     * @throws NullPointerException if the specified collection is null
     */
    public ArrayList(Collection<? extends E> c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
    举栗子说明:
     LinkedList<Object> linkedList = new LinkedList<>();
        linkedList.add(1);
        linkedList.add(2);
        linkedList.add(3);
        ArrayList<Object> objects = new ArrayList<>(linkedList);
        for (Object object : objects) {
            System.out.println(object);
        }
    // 1 2 3
```
##### 1.1.2.3 扩容机制
 - 扩容变化:
   - 每次扩容 50% , 亦新容量为旧容量的1.5倍
```
  思考下,什么时候会扩容? 肯定是装不下东西的时候会扩容哦,所以我们从添加元素 方法开始;
```
 **[1]** add 方法
   - 默认添加到尾部

```
 [1] add方法添加元素
  public boolean add(E e) {
        //在添加元素前调用ensureCapacityInternal方法,进行容量检验,看能否装得下;
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
    
 [2] ensureCapacityInternal检验容量
  private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }
    
 [3]实质检验方法 ensureExplicitCapacity
 private void ensureExplicitCapacity(int minCapacity) {
        // modCount 用来记录 ArrayList 结构发生变化的次数，因为每次在进行 add() 和 addAll() 时都需要调用 ensureCapacity()，因此直接在 ensureExplicitCapacity()中对 modCount 进行修改
        modCount++;
        // overflow-conscious code
        // 看下
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
```
   
  
  



    
