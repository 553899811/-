<a name="Tg5EW"></a>
# 1.Redis 过期策略
- [x] **Redis采用 惰性删除 和 定期删除 搭配方案**
<a name="uk5VW"></a>
## 1.1 定时删除（不使用）
<a name="icpN9"></a>
### 1.1.1 含义
在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除；
<a name="MZspE"></a>
### 1.1.2 优点
保证内存被尽快释放
<a name="0x07u"></a>
### 1.1.3 缺点

- 若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key
- 定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重；

<a name="AmGa3"></a>
## 1.2 惰性删除
<a name="2qgUo"></a>
### 1.2.1 含义
每次从redis中获取key的时候去检查是否过期，若过期，则删除，返回null。
<a name="4j7ug"></a>
### 1.2.2 优点
删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）
<a name="H5alH"></a>
### 1.2.3 缺点
若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）
<a name="xhnnM"></a>
## 1.3 定期删除
<a name="pOlZZ"></a>
### 1.3.1 含义
每隔一段时间执行一次删除过期key操作
<a name="niyXn"></a>
### 1.3.2 优点

- 通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理"定时删除"的缺点
- 定期删除过期key--处理"惰性删除"的缺点；
<a name="lHwRN"></a>
### 1.3.3 缺点

- 在内存友好方面，不如“定时删除”。
- 在CPU时间友好方面，不如“惰性删除”。
<a name="X8eKg"></a>
### 1.3.4 难点
合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率(每隔多长时间做一次删除）


<a name="JD9kE"></a>
## 1.4 Redis持久化对过期Key的处理

<a name="oZany"></a>
### 1.4.1 RDB对过期Key的处理

过期key对RDB没有任何影响；

- 从内存数据库持久化数据到RDB文件
   - 持久化key之前，会检查是否过期，过期的key不进入RDB文件
- 从RDB文件恢复数据到内存数据库
   - 数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）

<a name="QYiY7"></a>
### 1.4.2 AOF对过期Key的处理

过期key对AOF没有任何影响；

- 从内存数据库持久化数据到AOF文件：
   - 当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）
   - 当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）
- AOF重写
   - 重写时，会先判断key是否过期，已过期的key不会重写到aof文件 

<a name="x6zXc"></a>
# 2.Redis 内存淘汰机制
采用 惰性删除和 定期删除就没其他问题了吗？很明显，不可能。存在一种这样的情况，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用**内存淘汰机制**。<br />在Redis.conf有一行这样的配置
```cpp
maxmemory-policy volatile-lru
```
<a name="yNe5x"></a>
## 2.1 noeviction （驱逐）
当内存不足以容纳新写入数据时，新写入操作会报错。
<a name="ZzWXV"></a>
## 2.2 allkeys-lru
从数据集中挑选最近最少使用的数据淘汰<br />当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
<a name="7Z42r"></a>
## 2.3 allkeys-lfu
从数据集中挑选使用频率最低的数据淘汰。
<a name="Yjm7Q"></a>
## 2.4 allkeys-random
从数据集（server.db[i].dict）中任意选择数据淘汰<br />当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。（恐怖，这不是乱删吗？）
<a name="J9wku"></a>
## 2.5 volatile-lru
从已设置过期时间的数据集中挑选**最近最少使用**的数据淘汰；<br />当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
<a name="p27Ot"></a>
## 2.6 volatile-lfu（线上配置）
从所有配置了过期时间的键中驱逐使用频率最少的键。
<a name="3cBBe"></a>
## 2.7 volatile-random
当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key
<a name="E6OCF"></a>
## 2.8 volatile-ttl
从已设置过期时间的数据集中挑选将要过期的数据淘汰。

<a name="Puw1g"></a>
# 引用
[https://blog.csdn.net/sinat_30333853/article/details/80586161](https://blog.csdn.net/sinat_30333853/article/details/80586161)
