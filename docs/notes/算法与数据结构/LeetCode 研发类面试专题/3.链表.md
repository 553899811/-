| 一级类目 | 二级类型/题目 | 三级类目/题目 |
| :---: | :---: | :---: |
| 单链表 | 链表中的加法 | [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/) |
|  |  | [面试题 02.05. 链表求和](https://leetcode-cn.com/problems/sum-lists-lcci/) |
|  |  | [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/) |
| 双链表 | [面试题 16.25. LRU 缓存](https://leetcode-cn.com/problems/lru-cache-lcci/) |  |

<a name="ywJmS"></a>
# 单链表
<a name="NvxNT"></a>
## 链表中的加法
<a name="WPgYj"></a>
#### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)
```java
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *head=nullptr,*tail=nullptr;
        int first=0,second=0;
        int carry=0;
        while(l1||l2){
            first=l1?l1->val:0;
            second=l2?l2->val:0;
            int sum=first+second+carry;
            if(!head){
                head=tail=new ListNode(sum%10);
            }else {
                tail->next=new ListNode(sum%10);
                tail=tail->next;
            }
            carry=sum/10;
            if(l1)l1=l1->next;
            if(l2)l2=l2->next;
        }
        if(carry){tail->next=new ListNode(carry);}
        return head;
    }
};
```
<a name="L3Dg4"></a>
#### [面试题 02.05. 链表求和](https://leetcode-cn.com/problems/sum-lists-lcci/)
代码和上题一样
<a name="BRGIh"></a>
#### [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)

- 思路
```java
先分别反转，相加，然后再反转输出;
```
```java
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        ListNode *ll1 = reverse(l1);
        ListNode *ll2 = reverse(l2);
        int sum = 0, carry = 0;
        ListNode *head = nullptr, *tail = nullptr;
        while (ll1 || ll2) {
            int left = ll1 ? ll1->val : 0;
            int right = ll2 ? ll2->val : 0;
            sum = left + right + carry;
            if (!head) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail->next = new ListNode(sum % 10);
                tail = tail->next;
            }
            carry = sum / 10;
            if (ll1)ll1 = ll1->next;
            if (ll2)ll2 = ll2->next;
        }
        if (carry) {
            tail->next = new ListNode(carry);
        }
        return reverse(head);
    }

    ListNode *reverse(ListNode *l) {
        if (l == nullptr || l->next == nullptr) {
            return l;
        }
        // 1->2->3
        ListNode *prev = nullptr, *next = l;
        while (l) {
            next = l->next;
            l->next = prev;
            prev = l;
            l = next;
        }
        return prev;
    }
};
```
<a name="wCrJc"></a>
# 双链表
<a name="Btdu7"></a>
### [面试题 16.25. LRU 缓存](https://leetcode-cn.com/problems/lru-cache-lcci/)
```java
struct DLinkedNode {
    int key, value;
    DLinkedNode *prev;
    DLinkedNode *next;

    DLinkedNode() : key(0), value(0), prev(nullptr), next(nullptr) {}

    DLinkedNode(int key, int value) : key(key), value(value), prev(nullptr), next(nullptr) {}
};

class LRUCache {

private:
    unordered_map<int, DLinkedNode *> cache;
    DLinkedNode *head;
    DLinkedNode *tail;
    int size;
    int capacity;

public:
    LRUCache(int _capacity) : capacity(_capacity), size(0) {
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }

    int get(int key) {
        if (!cache.count(key)) {
            return -1;
        }
        DLinkedNode *node = cache[key];
        moveToHead(node);
        return node->value;
    }

    void put(int key, int value) {
        if (!cache.count(key)) {
            DLinkedNode *node = new DLinkedNode(key, value);
            cache[key] = node;
            addToHead(node);
            ++size;
            if (size > capacity) {
                DLinkedNode *tail = removeTail();
                cache.erase(tail->key);
                delete tail;
                size--;
            }
        } else {
            DLinkedNode *node = cache[key];
            node->value = value;
            // 将这个节点移动到头部位置;
            moveToHead(node);
        }
    }

    void moveToHead(DLinkedNode *node) {
        removeNode(node);
        addToHead(node);
    }

    void addToHead(DLinkedNode *node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }

    void removeNode(DLinkedNode *node) {
        // 拆断 双向链表中的双向;
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    DLinkedNode *removeTail() {
        DLinkedNode *node = tail->prev;
        removeNode(node);
        return node;
    }
};
```


