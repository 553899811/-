# 2.1 进程概论

<a name="n6AXo"></a>
# 进程的概念
进程是系统进行资源分配和调度的基本单位，线程是CPU调度和分派的基本单位。<br />
<br />程序：是静态的，就是一个存放在磁盘里的可执行文件，就是一系列的指令集合。<br />进程：是动态的，是程序的一次执行过程。
<a name="O2eLM"></a>
# 进程的组成
当进程被创建时，操作系统会为该进程分配一个唯一的，不重复的“身份证号”--PID（Process ID,进程ID）
<a name="tDfci"></a>
## 进程控制块PCB
![](https://cdn.nlark.com/yuque/0/2020/svg/177460/1590071436290-282a5b24-397e-41ea-87e5-13d66d57d777.svg)PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。<br />

![](https://cdn.nlark.com/yuque/0/2020/svg/177460/1590071436330-7928647a-3dc3-4518-9efb-5c3b50e66d0c.svg)PCB是给操作系统的。<br />数据段和程序块是给进程自己使用的。与进程自身的运行逻辑有关。<br />
<br />

<a name="Pa4vt"></a>
## 知识滚雪球：程序是如何运行的？
![image.png](https://cdn.nlark.com/yuque/0/2020/png/177460/1589262138794-7a9889dd-8c13-4c5f-9bbd-2b79daf1689a.png#align=left&display=inline&height=750&margin=%5Bobject%20Object%5D&name=image.png&originHeight=750&originWidth=1334&size=726815&status=done&style=none&width=1334)<br />**重点理解**：进程在内存中的运作。
<a name="7vd7n"></a>
# 进程的特征
![](https://cdn.nlark.com/yuque/0/2020/svg/177460/1590071436325-b69c4027-3931-4928-a76f-e9b40c0778fe.svg)<a name="amRQu"></a>
# 进程的状态与转换
<a name="kqw04"></a>
## 进程状态分类
<a name="AFadi"></a>
### 创建状态 （New,又称之为：新建态）
进程正在被创建，操作系统为进程分配资源，初始化PCB。
<a name="DsSym"></a>
### 就绪状态
已经具备运行条件，但由于没有空闲CPU，而暂时不能运行。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/177460/1589298705756-13a3f0c6-a3ac-4848-89ed-7ba3bece2cb9.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=750&originWidth=1334&size=588163&status=done&style=none&width=667)
<a name="HSpZB"></a>
### 运行状态
占有CPU，并在上搞事情运行。<br />如果一个进程此时在CPU上运行，那么这个进程处于“运行态”。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/177460/1589299807979-1b510fcc-4602-4b5b-98ce-e35149042de5.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=750&originWidth=1334&size=819266&status=done&style=none&width=667)
<a name="5l5Hr"></a>
### 阻塞状态
等待被调度的状态，因等待某一件事而暂时不能运行。<br />
<br />在进程运行的过程中,可能会请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应）。在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程暂时释放CPU，并让他进入“阻塞态”。当CPU空闲时，又会选择另一个“继续态”进程上CPU执行。
<a name="3iEtV"></a>
### 终止状态
对于进程来讲，可以执行exit系统调用，请求操作系统终止该进程。此时该进程会进入“终止态”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。
<a name="JKzTR"></a>
## 进程状态间的转换
![](https://cdn.nlark.com/yuque/0/2020/png/177460/1589300900234-d6621ce2-b56b-4d3e-a8a5-ec301dff3d16.png#align=left&display=inline&height=639&margin=%5Bobject%20Object%5D&originHeight=639&originWidth=1167&size=0&status=done&style=none&width=1167)<br />需要注意：<br />

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。
<a name="a06cS"></a>
# 进程的组织
<a name="CRii3"></a>
# 进程控制


<a name="A4wlZ"></a>
# 进程通信
<a name="1UMIK"></a>
## 进程通信的概念
进程通信就是指进程之间的信息交换。<br />进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。<br />为了安全起见，一个进程不能直接访问另一个进程的地址空间。

       每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为**进程间通信（IPC，InterProcess Communication）**<br />**![](https://cdn.nlark.com/yuque/0/2020/webp/177460/1590071129312-636fb1f9-0795-459a-8f60-d01bf1ed714e.webp#align=left&display=inline&height=181&margin=%5Bobject%20Object%5D&originHeight=181&originWidth=222&size=0&status=done&style=none&width=222)
<a name="r0EKy"></a>
## 进程通信的方式
<a name="RHeLR"></a>
### 1. 共享存储
两个进程对共享空间的访问必须是互斥的（操作系统只负责提供共享空间和同步互斥操作工具，如P,V操作）<br />

<a name="NtnK6"></a>
### 共享存储方式

- 基于数据结构的共享

       限制存储数据的形式，比如只能放数据，导致速度慢。

- 基于存储区的共享

      数据形式和存放位置都由进程控制，而不是操作系统，速度更快。
<a name="eeAlX"></a>
### 2. 管道/匿名管道通信（pipe）
管道：可以理解为用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。在Linux 中，管道大小等于内存页面的大小，4KB。<br />![](https://cdn.nlark.com/yuque/0/2020/webp/177460/1590071475112-560def2a-8a6e-42d0-b99e-e2460cbf8123.webp#align=left&display=inline&height=189&margin=%5Bobject%20Object%5D&originHeight=189&originWidth=228&size=0&status=done&style=none&width=228)

- 管道只能采用[半双工](https://blog.csdn.net/komtao520/article/details/88084984)通信，某一时间段内只能实现单向的传输。如果要实现双向同事通信，则需要设置两个管道。 
- 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）
- 各个进程要互斥地访问管道。    
- 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。
- 如果没写满，就不允许读。如果没读空，就不允许写。
- 数据一旦读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能就会有读错数据的情况。
- 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。
<a name="yAFTt"></a>
#### 管道的实质

- 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
- 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
- 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。
<a name="F6Koc"></a>
#### 管道的局限
管道的主要局限性正体现在它的特点上：

- [x] 只支持单向数据流
- [x] 只能用于具有亲缘关系的进程之间；
- [x] 没有名字
- [x] 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；
- [x] 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；
<a name="9jPXo"></a>
### 3. 有名管道（FIFO）
<a name="vBOMt"></a>
### [https://www.jianshu.com/p/c1015f5ffa74](https://www.jianshu.com/p/c1015f5ffa74)
<br />
