# 2.1 进程与线程

<a name="n6AXo"></a>
# 进程的概念
程序：是静态的，就是一个存放在磁盘里的可执行文件，就是一系列的指令集合。<br />进程：是动态的，是程序的一次执行过程。
<a name="O2eLM"></a>
# 进程的组成
当进程被创建时，操作系统会为该进程分配一个唯一的，不重复的“身份证号”--PID（Process ID,进程ID）
<a name="tDfci"></a>
## 进程控制块PCB
![](https://cdn.nlark.com/yuque/0/2020/svg/177460/1589815696809-4effbea8-ba8e-4f57-9f02-450d7cc2f34a.svg)PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。<br />

![](https://cdn.nlark.com/yuque/0/2020/svg/177460/1589815696832-6c1c7e5b-4bee-480d-bf8c-603937f94828.svg)PCB是给操作系统的。<br />数据段和程序块是给进程自己使用的。与进程自身的运行逻辑有关。<br />
<br />

<a name="Pa4vt"></a>
## 知识滚雪球：程序是如何运行的？
![image.png](https://cdn.nlark.com/yuque/0/2020/png/177460/1589262138794-7a9889dd-8c13-4c5f-9bbd-2b79daf1689a.png#align=left&display=inline&height=750&margin=%5Bobject%20Object%5D&name=image.png&originHeight=750&originWidth=1334&size=726815&status=done&style=none&width=1334)<br />**重点理解**：进程在内存中的运作。
<a name="7vd7n"></a>
# 进程的特征
![](https://cdn.nlark.com/yuque/0/2020/svg/177460/1589815696862-9ac5c3d5-503c-4570-8b03-7dd7c6ac7edd.svg)<a name="amRQu"></a>
# 进程的状态与转换
<a name="kqw04"></a>
## 进程状态分类
<a name="AFadi"></a>
### 创建状态 （New,又称之为：新建态）
进程正在被创建，操作系统为进程分配资源，初始化PCB。
<a name="DsSym"></a>
### 就绪状态
已经具备运行条件，但由于没有空闲CPU，而暂时不能运行。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/177460/1589298705756-13a3f0c6-a3ac-4848-89ed-7ba3bece2cb9.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=750&originWidth=1334&size=588163&status=done&style=none&width=667)
<a name="HSpZB"></a>
### 运行状态
占有CPU，并在上搞事情运行。<br />如果一个进程此时在CPU上运行，那么这个进程处于“运行态”。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/177460/1589299807979-1b510fcc-4602-4b5b-98ce-e35149042de5.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=750&originWidth=1334&size=819266&status=done&style=none&width=667)
<a name="5l5Hr"></a>
### 阻塞状态
等待被调度的状态，因等待某一件事而暂时不能运行。<br />
<br />在进程运行的过程中,可能会请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应）。在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程暂时释放CPU，并让他进入“阻塞态”。当CPU空闲时，又会选择另一个“继续态”进程上CPU执行。
<a name="3iEtV"></a>
### 终止状态
对于进程来讲，可以执行exit系统调用，请求操作系统终止该进程。此时该进程会进入“终止态”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。
<a name="JKzTR"></a>
## 进程状态间的转换
![](https://cdn.nlark.com/yuque/0/2020/png/177460/1589300900234-d6621ce2-b56b-4d3e-a8a5-ec301dff3d16.png#align=left&display=inline&height=639&margin=%5Bobject%20Object%5D&originHeight=639&originWidth=1167&size=0&status=done&style=none&width=1167)<br />需要注意：<br />

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。
<a name="a06cS"></a>
# 进程的组织
<a name="CRii3"></a>
# 进程控制


<a name="A4wlZ"></a>
# 进程通信
进程通信就是指进程之间的信息交换。<br />进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。<br />为了安全起见，一个进程不能直接访问另一个进程的地址空间。
<a name="r0EKy"></a>
## 1. 共享存储
两个进程对共享空间的访问必须是互斥的（操作系统只负责提供共享空间和同步互斥操作工具，如P,V操作）<br />

<a name="NtnK6"></a>
### 共享存储方式

- 基于数据结构的共享

       限制存储数据的形式，比如只能放数据，导致速度慢。

- 基于存储区的共享

      数据形式和存放位置都由进程控制，而不是操作系统，速度更快。
<a name="BISfw"></a>
## 2. 管道通信
管道：可以理解为用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。在Linux 中，管道大小等于内存页面的大小，4KB。

- 管道只能采用[半双工](https://blog.csdn.net/komtao520/article/details/88084984)通信，某一时间段内只能实现单向的传输。如果要实现双向同事通信，则需要设置两个管道。 
- 各个进程要互斥地访问管道。
- 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。
- 如果没写满，就不允许读。如果没读空，就不允许写。
- 数据一旦独处，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能就会有读错数据的情况。
<a name="Z31KH"></a>
## 3. 消息传递
传递结构化的消息（消息头/消息体）