# 2.3 处理机调度

<a name="1QzUi"></a>
# 1.调度概念
```java
任务很多，资源有限，没法做到同时处理，这时候就需要确定某种规则来决定处理任务的顺序，
这就是处理机调度要研究的问题。

在多到程序系统中，进程数大于CPU个数，此时处理机要按照一定的算法选择一个进程并将处理器分配给它 运行。
```
<a name="GxAM7"></a>
# 2.调度算法
<a name="Drmd1"></a>
## 2.1 先到先服务（FCFS，队列实现，非抢占）
![](https://cdn.nlark.com/yuque/0/2020/svg/177460/1590885950775-00a696dd-146f-4324-8e8a-cb9ae189689d.svg)<a name="woRJe"></a>
## 2.2 短作业优先（SJF，最短作业优先调度算法）
<a name="smKA2"></a>
### 短作业/进程优先调度算法
```java
每次调度时选择当前已到达且运行时间最短的作业/进程。
```
<a name="PiL5v"></a>
### ![image.png](https://cdn.nlark.com/yuque/0/2020/png/177460/1590846287783-c47722bb-171b-438b-bf30-b76d10a4327d.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=750&originWidth=1334&size=527102&status=done&style=none&width=667)
```java
当第0秒时，P1到达，就开始运行P1。
当第7秒时，P1执行完毕，此时P2,P3,P4都已经到达，选择最短作业就是P3，开始执行
当第8秒时，P3执行完毕，此时P2,P4处于就绪状态，并且他们两个作业时间相同，按照到达顺序进行执行，执行P2
当第12秒时，P2执行完毕，P4处于就绪状态，开始执行P4
当第16秒时，P4执行完毕。
```
<a name="VKhZ1"></a>
### 最短剩余时间优先算法
```java
最短剩余时间优先算法: 每当有进程加入就绪队列时就要重新调整调度，
如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，
当前进行进程重新回到就绪队列，此外，当一个进程完成时也需要重新调整调度方案。
```
![image.png](https://cdn.nlark.com/yuque/0/2020/png/177460/1590845700102-35e54f81-9541-4209-a280-35404f98f4ed.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=750&originWidth=1334&size=802541&status=done&style=none&width=667)<br />如上图这个例子，四个进程执行完毕，一共花的时间是 7+4+1+4=16, 但是根据短作业优先，在11时刻时就有三个进程完成作业，对短作业友好，无需因存在长作业而要等待很长时间。
```java
第0秒时，P1到达，开始执行
第2秒时，P2到达，此时P1剩余作业时间5秒，P2剩余时间4秒，开始执行P2，P1暂停，进入到就绪状态。
第4秒时，P3到达，此时P1剩余作业时间5秒，P3剩余作业时间1秒，P2剩余作业时间2秒，开始执行P3
第5秒时，P4到达，P3执行完毕，此时P1剩余作业时间5秒，P4剩余作业时间4秒，P2剩余作业时间2秒，开始执行P2
第7秒时，P2执行完毕，此时P1剩余作业时间5秒，P4剩余作业时间4秒，开始执行P4
第11秒时，P4执行完毕，开始执行P1
第16秒时，P1执行完毕。
```
![](https://cdn.nlark.com/yuque/0/2020/svg/177460/1590885950802-3b1428c2-7f31-404f-93f0-f6ba4e4ddfd1.svg)<a name="QyIDk"></a>
## 2.3 高响应比优先（HRRN）
高响应比优先算法
```java
非抢占式的调度算法，只有当前运行的进程主动放弃CPU时（正常/异常完成，或者主动阻塞），才需要进行调度，
调度时计算所有就绪进程的响应比，选响应比最高的进程处理。

响应比=（等待时间+要求服务时间）/（要求服务时间）
```
![image.png](https://cdn.nlark.com/yuque/0/2020/png/177460/1590884539418-804f7678-c14a-4ece-b0ec-4331b8efd519.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=750&originWidth=1334&size=713259&status=done&style=none&width=667)
```java
第0秒，P1到达就绪队列，P1上处理器开始处理。
第7秒，P1执行完毕，主动放弃CPU，此时在就绪队列上，
       有P2(等待时间5秒，要求服务时间4秒),P2(响应比=(5+4)/4=2.25)
       有P3(等待时间3秒，要求服务时间1秒),P3(响应比=(3+1)/1=4)
       有P4(等待时间2秒，要求服务时间4秒),P4(响应比=(2+4)/4=1.5)
       优先处理P3
第8秒，P3执行完毕，主动放弃CPU，此时在就绪队列上，
       有P2(等待时间6秒，要求服务时间4秒),P2(响应比=(6+4)/4=2.5)
       有P4(等待时间3秒，要求服务时间4秒),P3(响应比=(3+4)/4=1.75)
       优先处理P2
第12秒，P2执行完毕，主动放弃CPU，开始处理P4

```
![](https://cdn.nlark.com/yuque/0/2020/svg/177460/1590885950808-2a8c3ada-3830-478f-acf8-78f54ede0b69.svg)<a name="fT12p"></a>
### 优缺点
```java
综合考虑了等待时间和运行时间（要求服务时间），等待时间相同时，要求服务时间短的优先（SJF的优点，短作业优先）
要求服务时间相同时，等待时间长的优先（FCFS的优点，先到先服务）
对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题。
```
<a name="0Ipna"></a>
## 2.4 时间片轮转调度算法


<a name="axBOI"></a>
# 引用
[非抢占式和抢占式进程调度的区别](https://blog.csdn.net/qq_34173549/article/details/79936219)
