<a name="W4SBL"></a>
# 1.InnoDB与MyISAM对比
| **特性** | **InnoDB ** | **MyISAM ** |
| --- | --- | --- |
| 事务 | 支持 | 不支持 |
| 锁 | 行锁&&表锁 | 表锁 |
| 缓存 | 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 | 只缓存索引，不缓存真实数据 |
| 外键 | 支持 | 不支持 |
| 索引类型 | 主键：聚簇索引 | 非聚簇索引 |
| 备份 | 热备份 | 不支持 |

- InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；
- **InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁**；
- InnoDB 支持外键，MyISAM 不支持外键；
- MyISAM 性能比 InnoDB 高；
- InnoDB 主键查询性能高于 MyISAM。
<a name="BvE6x"></a>
## 1.1 MyISAM
不支持行级锁。<br />只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。
<a name="outrB"></a>
### 

<a name="nuaXo"></a>
### 4.如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？
可以回表查询，如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。

<a name="oILrl"></a>
### 6.MySQL 中内连接、左连接、右连接有什么区别？

- 内连（inner join）— 把匹配的关联数据显示出来；
- 左连接（left join）— 把左边的表全部显示出来，右边的表显示出符合条件的数据；
- 右连接（right join）— 把右边的表全部显示出来，左边的表显示出符合条件的数据；
<a name="Zuiyn"></a>
### <br />7.SQL语句执行顺序
先执行from关键字后面的语句，明确数据的来源，它是从哪张表取来的。<br />接着执行where关键字后面的语句，对数据进行筛选。<br />再接着执行group by后面的语句，对数据进行分组分类。<br />然后执行select后面的语句，也就是对处理好的数据，具体要取哪一部分。<br />最后执行order by后面的语句，对最终的结果进行排序。

<a name="t2jNE"></a>
### 8.索引为啥会失效？
| <br />1. 不要在索引列上进行运算或使用函数<br /> |
| --- |
| <br />2. 前导模糊查询不会使用索引，例如 like %李<br /> |
| <br />3. 负向条件索引不会使用索引，建议用in。负向条件有：!=、<>、not in、not exists、not like 等；<br /> |

<a name="EuJjt"></a>
### 9.为什么主键通常建议使用自增id

使用自增 id 可以避免页分裂<br />**聚簇索引的数据的物理存放顺序与索引顺序是一致的**，即：**只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的**。如果主键不是自增id，那么可以想 象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。
<a name="MXZaK"></a>
### 10.索引覆盖

索引覆盖使用联合索引在特定情况下 ，避免回表查。<br />创建 联合索引 A,B,C <br />查询的时候正好查A,B,C 这三个字段，索引就避免回表查其他内容了。直接返回即可。
<a name="Zi4Rv"></a>
### [<br /><br /><br /><br /><br /><br /><br />](https://blog.csdn.net/ycf921244819/article/details/90273828)

<a name="yYlZP"></a>
### 12. 设计表的时候需要注意哪些
<a name="tGaNU"></a>
# 常见问题
<a name="AqXFo"></a>
### 1. 在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？

- 对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。
- 对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。
- 对于 count(字段) 来说，如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。
- 对于 count(*) 来说，并不会把全部字段取出来，而是专门做了优化，不取值，直接按行累加。

所以最后得出的结果是：count(字段)<count(主键 id)<count(1)≈count(*)。

<a name="TCMnK"></a>
# 引用

[https://www.cnblogs.com/yaowen/p/8862108.html](https://www.cnblogs.com/yaowen/p/8862108.html)
