| 标记阶段（对象还活着吗？） | **引用计数算法** |
| :---: | --- |
|  | **可达性分析算法** |
| 清除阶段 | **复制算法** |
|  | **标记-清除算法** |
|  | **标记-整理算法** |

<a name="73c45f59"></a>
# 1. 标记阶段-引用计数算法
<a name="udkv5"></a>
## 1.1 概念
引用计数算法：对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。

对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。
<a name="GTCJo"></a>
## 1.2 优点
实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
<a name="n2D4L"></a>
## 1.3 缺点

- 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
- 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。
<a name="5Rx3x"></a>
### 1.3.1 循环引用
![](https://cdn.nlark.com/yuque/0/2021/png/177460/1617082501859-90eec7cb-0739-4477-850c-616f82cdd3bd.png#align=left&display=inline&height=516&margin=%5Bobject%20Object%5D&originHeight=516&originWidth=942&size=0&status=done&style=none&width=942)<br />当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏。<br />


![image.png](https://cdn.nlark.com/yuque/0/2021/png/177460/1617083952574-ddcb1a97-5416-4309-b40a-d99e05a2009a.png#align=left&display=inline&height=387&margin=%5Bobject%20Object%5D&name=image.png&originHeight=773&originWidth=1591&size=557527&status=done&style=none&width=795.5)<br />如果使用引用计数算法，那么这两个对象将无法回收。
<a name="GQubA"></a>
# 2. 标记阶段：可达性分析算法
<a name="6kTuc"></a>
## 2.1 概念
可达性分析算法：根搜索算法，追踪性垃圾收集<br />
<br />相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。
<a name="Olzqc"></a>
## 2.2 思路

- 可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
- 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）
- 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。
- 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

![](https://cdn.nlark.com/yuque/0/2021/png/177460/1617086779186-1d56b70f-627d-4c88-87d0-09f72c79812f.png#align=left&display=inline&height=502&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=920&size=0&status=done&style=none&width=920)
<a name="vW78w"></a>
## 2.3 GC Roots可以是哪些？
| **虚拟机栈中引用的对象** | <br />- 比如：各个线程被调用的方法中使用到的参数、局部变量等。<br /> |
| --- | --- |
| **本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象** | <br />- 比如：Java类的引用类型静态变量<br /> |
| **方法区中常量引用的对象** | <br />- 比如：字符串常量池（string Table）里的引用<br /> |
| **所有被同步锁synchronized持有的对象** |  |

<a name="RVckE"></a>
## 2.4 总结
总结一句话就是，除了堆空间外的一些结构，比如 虚拟机栈、本地方法栈、方法区、字符串常量池 等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析。
<a name="F9EzC"></a>
### 2.4.1 注意
如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。<br />这点也是导致GC进行时必须“stop The World”的一个重要原因。<br />即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。

<a name="nt9sq"></a>
# 3.对象的finalization机制
<a name="MGJA1"></a>
## 3.1 生存还是死亡？
如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。**一个无法触及的对象有可能在某一个条件下“复活”自己**，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：

- 可触及的：从根节点开始，可以到达这个对象。
- 可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。
- 不可触及的：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为**finalize()只会被调用一次**。
<a name="9xfBP"></a>
## 3.2 具体过程
判定一个对象objA是否可回收，至少要经历两次标记过程：

- 如果对象objA到GC Roots没有引用链，则进行第一次标记。<br />
- 进行筛选，判断此对象是否有必要执行finalize（）方法
   - 如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。
   - 如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。
   - finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。
<a name="f2iRs"></a>
# 4.清除阶段：复制算法
<a name="Z8axT"></a>
## 4.1 核心思想
将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收<br />![](https://cdn.nlark.com/yuque/0/2021/png/177460/1617105715096-2dd0bc27-0bab-4c01-9a08-e00ee380a0e4.png#align=left&display=inline&height=539&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1040&size=0&status=done&style=none&width=1040)<br />
<br />
<br />把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的**新生代里面就用到了复制算法**

![](https://cdn.nlark.com/yuque/0/2021/png/177460/1617105730465-5c955d02-5d47-47e7-bd8a-e48e34b98f85.png#align=left&display=inline&height=407&margin=%5Bobject%20Object%5D&originHeight=407&originWidth=1003&size=0&status=done&style=none&width=1003)
<a name="9WdLN"></a>
## 4.1 优点

- 没有标记和清除过程，实现简单，运行高效
- 复制过去以后保证空间的连续性，不会出现“碎片”问题。
<a name="hlij9"></a>
## 4.2 缺点

- 此算法的缺点也是很明显的，就是需要两倍的内存空间。（消耗更多的内存空间）
- 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小
<a name="dE0dZ"></a>
## 4.3 注意

- 在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。
- 老年代大量的对象存活，如果复制这些，效率会很低下。
<a name="cXRmh"></a>
# 5.清除阶段：标记-清除算法
<a name="EY0PE"></a>
## 5.1 核心思想


当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除

- **标记**：Collector从引用根节点开始遍历，**标记所有被引用的对象**。一般是在对象的**Header**中记录为可达对象。
   - **标记的是引用的对象，不是垃圾！！**
- **清除**：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。

![](https://cdn.nlark.com/yuque/0/2021/png/177460/1617107377933-fe3f911d-4de5-46cc-a456-044d260ca8b2.png#align=left&display=inline&height=652&margin=%5Bobject%20Object%5D&originHeight=652&originWidth=832&size=0&status=done&style=none&width=832)<br />

<a name="lbGHg"></a>
## 5.2 什么是清除 ？
这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。

关于空闲列表是在为对象分配内存的时候 提过

- 如果内存规整
   - 采用指针碰撞的方式进行内存分配（[指针碰撞和空闲列表](https://blog.csdn.net/yun_ld/article/details/105103011)，指针碰撞即内存连续分配；空闲列表：记录离散的数据内存区域，因为没有连续的内存区域存这个对象）
- 如果内存不规整
   - 虚拟机需要维护一个列表
   - 空闲列表分配
```java
补充：指针碰撞：
所有用过的内存放在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲挪动
一段与对象大小相等的距离。
```
<a name="fPsAn"></a>
## 5.3 缺点

- 标记清除算法的效率不算高
- 在进行GC的时候，需要停止整个应用程序，用户体验较差
- 这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表



<a name="vyX8I"></a>
# 6.清除阶段：标记-整理算法
<a name="D4jTk"></a>
## 6.1 核心思想
第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象<br />第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。<br />![](https://cdn.nlark.com/yuque/0/2021/png/177460/1617107705621-4491d33f-569c-4c87-87ba-271cd79fa291.png#align=left&display=inline&height=538&margin=%5Bobject%20Object%5D&originHeight=538&originWidth=667&size=0&status=done&style=none&width=667)
<a name="kmOlo"></a>
## 6.2 标记清除和标记整理的区别
标记-整理算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。<br />
<br />
<br />二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-整理是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。<br />

<a name="gsl0w"></a>
## 6.3 优点

- 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
- 消除了复制算法当中，内存减半的高额代价。
<a name="HvLsa"></a>
## 6.4 缺点

- 从效率上来说，**标记-整理算法要低于复制算法**。
- 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址
- 移动过程中，需要全程暂停用户应用程序。即：STW
<a name="ifKnq"></a>
# 7.引用
![image.png](https://cdn.nlark.com/yuque/0/2021/png/177460/1617628980916-51b5b16c-783b-4c77-9b43-a59ea3763249.png#align=left&display=inline&height=140&margin=%5Bobject%20Object%5D&name=image.png&originHeight=279&originWidth=990&size=38284&status=done&style=none&width=495)<br />Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用。<br />

- 强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Object（）”这种引用关系。无论任何情况下，==只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象==。
- 软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。
- 弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。
- 虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。==为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知==。
<a name="PsRI5"></a>
## 7.1 强引用


<a name="NV2R5"></a>
## 7.2 软引用
一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象

<a name="FnbWw"></a>
## 7.3 弱引用
发现即回收

<a name="p7J2E"></a>
## 7.4 虚引用
也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个<br />一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。<br />它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null<br />为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。<br />虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。<br />由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。
