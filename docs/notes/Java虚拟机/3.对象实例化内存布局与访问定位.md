<a name="i6sHh"></a>
## 3.1 创建对象的方式
- new Object(): 最常见的方法
- [x] 单例类中调用getInstance的静态类方法
- Class的newInstance方法
- 使用clone()：不调用任何的构造器
- 使用序列化：序列化一般用于Socket的网络传输
- 第三方库 Objenesis
<a name="J8B2q"></a>
## 3.2 创建对象的步骤
<a name="iDpFw"></a>
### 3.2.1 判断对象对应的类是否加载、链接、初始化
虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。
<a name="WSCu5"></a>
### 3.2.2 为对象分配内存
首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小；

如果内存规整，采用指针碰撞的方式分配；<br />如果内存不规整，虚拟机需要维护一个空闲列表分配。

<a name="A2Zc4"></a>
#### 3.2.2.1 指针碰撞
所有用过的内存放在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲挪动一段与对象大小相等的距离。 
<a name="OFzAC"></a>
#### 3.2.2.2 空闲列表
如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”

选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
<a name="0vuiQ"></a>
#### 
<a name="PrKHV"></a>
### 3.2.3 处理并发问题
对象创建是非常频繁的行为，还需要考虑并发情况下，仅仅修改一个指针所指向的位置也是不安全的，例如正在给对象A分配内存，指针还未修改，对象B又使用原来的指针分配内存。解决问题有两种可选方案：
<a name="cOp3L"></a>
#### 3.2.3.1 CAS同步控制
对分配内存空间的动作进行同步处理。实际上虚拟机采取CAS配上失败重试的方式保证更新操作的原子性。
<a name="WDzrh"></a>
#### 3.2.3.2 TLAB 本地线程分配缓冲
把内存分配的动作按照线程划分到不同的空间中进行，每个线程在Java堆中，预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。

- 虚拟机是否使用TLAB，可以通过-XX: +/-UseTLAB参数来设定。
<a name="zRrxg"></a>
### 3.2.4 初始化分配到的内存空间


<a name="eEl52"></a>
### 3.2.5 设置对象的对象头


<a name="GhQVH"></a>
### 3.2.6 执行init方法进行初始化

<br />

