| 标记阶段（对象还活着吗？） | **引用计数算法** |
| :---: | --- |
|  | **可达性分析算法** |
| 清除阶段 | **复制算法** |
|  | **标记-清除算法** |
|  | **标记-整理算法** |

<a name="73c45f59"></a>
# 1. 标记阶段-引用计数算法
<a name="udkv5"></a>
## 1.1 概念
引用计数算法：对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。

对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。
<a name="GTCJo"></a>
## 1.2 优点
实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
<a name="n2D4L"></a>
## 1.3 缺点

- 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
- 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。
<a name="5Rx3x"></a>
### 1.3.1 循环引用
![](https://cdn.nlark.com/yuque/0/2021/png/177460/1617082501859-90eec7cb-0739-4477-850c-616f82cdd3bd.png#align=left&display=inline&height=516&margin=%5Bobject%20Object%5D&originHeight=516&originWidth=942&size=0&status=done&style=none&width=942)<br />当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏。<br />


![image.png](https://cdn.nlark.com/yuque/0/2021/png/177460/1617083952574-ddcb1a97-5416-4309-b40a-d99e05a2009a.png#align=left&display=inline&height=387&margin=%5Bobject%20Object%5D&name=image.png&originHeight=773&originWidth=1591&size=557527&status=done&style=none&width=795.5)<br />如果使用引用计数算法，那么这两个对象将无法回收。
<a name="GQubA"></a>
# 2. 标记阶段：可达性分析算法
<a name="6kTuc"></a>
## 2.1 概念
可达性分析算法：根搜索算法，追踪性垃圾收集<br />
<br />相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。
<a name="Olzqc"></a>
## 2.2 思路

- 可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
- 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）
- 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。
- 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

![](https://cdn.nlark.com/yuque/0/2021/png/177460/1617086779186-1d56b70f-627d-4c88-87d0-09f72c79812f.png#align=left&display=inline&height=502&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=920&size=0&status=done&style=none&width=920)
<a name="vW78w"></a>
## 2.3 GC Roots可以是哪些？
| **虚拟机栈中引用的对象** | <br />- 比如：各个线程被调用的方法中使用到的参数、局部变量等。<br /> |
| --- | --- |
| **本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象** | <br />- 比如：Java类的引用类型静态变量<br /> |
| **方法区中常量引用的对象** | <br />- 比如：字符串常量池（string Table）里的引用<br /> |
| **所有被同步锁synchronized持有的对象** |  |

<a name="RVckE"></a>
## 2.4 总结
总结一句话就是，除了堆空间外的一些结构，比如 虚拟机栈、本地方法栈、方法区、字符串常量池 等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析。
<a name="F9EzC"></a>
### 2.4.1 注意
如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。<br />这点也是导致GC进行时必须“stop The World”的一个重要原因。<br />即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。

<a name="nt9sq"></a>
# 3.对象的finalization机制
<a name="MGJA1"></a>
## 3.1 生存还是死亡？
如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。**一个无法触及的对象有可能在某一个条件下“复活”自己**，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：

- 可触及的：从根节点开始，可以到达这个对象。
- 可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。
- 不可触及的：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为**finalize()只会被调用一次**。
<a name="9xfBP"></a>
## 3.2 具体过程
判定一个对象objA是否可回收，至少要经历两次标记过程：

- 如果对象objA到GC Roots没有引用链，则进行第一次标记。<br />
- 进行筛选，判断此对象是否有必要执行finalize（）方法
   - 如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。
   - 如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。
   - finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。
<a name="f2iRs"></a>
# 4.清除阶段：复制算法
<a name="Z8axT"></a>
## 4.1 核心思想
将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收<br />![](https://cdn.nlark.com/yuque/0/2021/png/177460/1617105715096-2dd0bc27-0bab-4c01-9a08-e00ee380a0e4.png#align=left&display=inline&height=539&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=1040&size=0&status=done&style=none&width=1040)<br />
<br />
<br />把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的**新生代里面就用到了复制算法**

![](https://cdn.nlark.com/yuque/0/2021/png/177460/1617105730465-5c955d02-5d47-47e7-bd8a-e48e34b98f85.png#align=left&display=inline&height=407&margin=%5Bobject%20Object%5D&originHeight=407&originWidth=1003&size=0&status=done&style=none&width=1003)
<a name="9WdLN"></a>
## 4.1 优点

- 没有标记和清除过程，实现简单，运行高效
- 复制过去以后保证空间的连续性，不会出现“碎片”问题。
<a name="hlij9"></a>
## 4.2 缺点

- 此算法的缺点也是很明显的，就是需要两倍的内存空间。（消耗更多的内存空间）
- 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小
<a name="dE0dZ"></a>
## 4.3 注意

- 在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。
- 老年代大量的对象存活，如果复制这些，效率会很低下。
<a name="cXRmh"></a>
# 5.清除阶段：标记-清除算法
<a name="EY0PE"></a>
## 5.1 核心思想


当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除

- **标记**：Collector从引用根节点开始遍历，**标记所有被引用的对象**。一般是在对象的**Header**中记录为可达对象。
   - **标记的是引用的对象，不是垃圾！！**
- **清除**：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。

![](https://cdn.nlark.com/yuque/0/2021/png/177460/1617107377933-fe3f911d-4de5-46cc-a456-044d260ca8b2.png#align=left&display=inline&height=652&margin=%5Bobject%20Object%5D&originHeight=652&originWidth=832&size=0&status=done&style=none&width=832)<br />

<a name="lbGHg"></a>
## 5.2 什么是清除 ？
这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。

关于空闲列表是在为对象分配内存的时候 提过

- 如果内存规整
   - 采用指针碰撞的方式进行内存分配（[指针碰撞和空闲列表](https://blog.csdn.net/yun_ld/article/details/105103011)，指针碰撞即内存连续分配；空闲列表：记录离散的数据内存区域，因为没有连续的内存区域存这个对象）
- 如果内存不规整
   - 虚拟机需要维护一个列表
   - 空闲列表分配
<a name="fPsAn"></a>
## 5.3 缺点

- 标记清除算法的效率不算高
- 在进行GC的时候，需要停止整个应用程序，用户体验较差
- 这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表



<a name="vyX8I"></a>
# 6.清除阶段：标记-整理算法
<a name="D4jTk"></a>
## 6.1 核心思想
第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象<br />第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。<br />![](https://cdn.nlark.com/yuque/0/2021/png/177460/1617107705621-4491d33f-569c-4c87-87ba-271cd79fa291.png#align=left&display=inline&height=538&margin=%5Bobject%20Object%5D&originHeight=538&originWidth=667&size=0&status=done&style=none&width=667)
<a name="kmOlo"></a>
## 6.2 标记清除和标记整理的区别
标记-整理算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。<br />
<br />
<br />二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-整理是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。<br />

<a name="gsl0w"></a>
## 6.3 优点

- 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
- 消除了复制算法当中，内存减半的高额代价。
<a name="HvLsa"></a>
## 6.4 缺点

- 从效率上来说，**标记-整理算法要低于复制算法**。
- 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址
- 移动过程中，需要全程暂停用户应用程序。即：STW



