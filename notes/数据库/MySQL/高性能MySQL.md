[TOC]

参考：
- [x] [从B树、B+树、B*树谈到R 树](http://blog.csdn.net/v_JULY_v/article/details/6530142/)
- [ ] 《Beginning Database Design》
- [ ] [MySql学习(七) —— 查询性能优化 深入理解MySql如何执行查询](http://www.cnblogs.com/chiangchou/p/6158918.html)
- [ ] [MySQL查询执行过程](http://www.cnblogs.com/yuyue2014/p/3826941.html)
- [ ] 《Relational Database index and the optimizers》
 

sql优化可以分几个思路：
1. 库表结构优化；
2. 建立合适的索引；
3. sql优化；

> 快速、精确、实现简单--往往只能满足两个。。。    

# Schema与数据库类型优化




## 选择优化的数据类型

IP地址--整型存储

tinyint unsigned



尽量避免NULL

### 整数类型

header 1 | 所占位数
---|---
tinyint | 8
smallint | 16
mediumint|24
int |32
bigint|64

可以存储的范围为：

```math
-2^{N-1}
```
到

```math
2^{N-1}-1
```
例如：tinyint 为 -128 ~ 127

### 实数类型

float、double支持使用标准的浮点运算进行近似计算；
decimal支持精确计算；

### 字符串类型

varchar 变长存储，需要额外1-2个字节记录字符串长度。
varchar(5),varchar(200)的空间开销是一样的，更长的列则会消耗更多的内存，因此，有时慷慨是不明智的。

blob以二进制存储；
text以字符串存储。


char 定长，

### 日期和时间类型

datetime ：

1001-9999
无时区信息


timestamp ：


1970-2038
比datetime空间效率高

### 位数据类型

MySQL把bit当作字符串类型，而不是数字类型，

MySQL5.0之后，bit可以存储多个true/false值，例如BIT(2)存储两个位，最大长度为64；

当前很多应用都适用字符串char(15)来存储IP地址（占用16个字节），利用inet_aton()和inet_ntoa()函数，来存储IP地址效率很高，适用unsigned int 就可以满足需求，不需要使用bigint，只需要4个字节，节省存储空间，同时效率也高很多。 


## 一些陷阱

- 避免太多列；
- 避免太多关联，一般为了保证查询速度快、并发性好，单个查询尽量限制在12个表以内；Mysql限制最多关联61张表；我们常见的EVA（实体、属性、值）其实是一种非常糟糕的设计模式；

## 范式与反范式


## 缓存表与汇总表

范式可以避免数据冗余，反范式可以很好的避免关联，这样有时即使没有索引（全表扫描），也可能比关联要快得多。没有太绝对的做法，有时添加==冗余字段==可能更为高效。
- 缓存表、汇总表。

```
CREATE TABLE msg_per_hr (

   hr DATETIME NOT NULL,

   cnt INT UNSIGNED NOT NULL,

   PRIMARY KEY(hr)

);

mysql> SELECT SUM(cnt) FROM msg_per_hr

    -> WHERE hr BETWEEN

    ->    CONCAT(LEFT(NOW(), 14), '00:00') - INTERVAL 23 HOUR

    ->    AND CONCAT(LEFT(NOW(), 14), '00:00') - INTERVAL 1 HOUR;

mysql> SELECT COUNT(*) FROM message

    -> WHERE posted >= NOW() - INTERVAL 24 HOUR

    ->    AND posted < CONCAT(LEFT(NOW(), 14), '00:00') - INTERVAL 23 HOUR;

mysql> SELECT COUNT(*) FROM message

    -> WHERE posted >= CONCAT(LEFT(NOW(), 14), '00:00');
```

- 物化视图


- 计数器表

很多web应用中都有计数的功能，例如 博客系统一般都会统计好友的数目，发表的文章数，上传的文件数，以及文章的被浏览数。如果 应用中存在较多的计数器，在高并发时，很容易出现“写”的性能问题，针对这种情况可以采取把Counter的字段作为一张单独表的解决方案。

 

·         以博客网站的访问次数为例，最简单的计数器表是只包含单独的计数列


```
mysql>CREATE TABLE hit_counter (

->  cnt int unsigned not null

-> )ENGINE=InnoDB;
```

每当被访问时cnt就执行一次更新操作



```
mysql>UPDATE  hit_counter  SET cnt = cnt + 1;
```

·当并发的数量比较大时，由于update是串行的操作，所以性能还是会受到影响，为了提高并发的Performance,  可以采用多条记录的方式来提高并发效率步骤如下

(1) 更改表结构


```
mysql>CREATE TABLE hit_counter (

->  slot tinyint unsigned not null primary key,

->  cnt int unsigned not null

-> )ENGINE=InnoDB;
```

(2) 执行更新操作时，根据并发的数量，随机的选择一条计数器记录（以100表记录为例)


```
mysql> UPDATE hit_counter SET cnt = cnt + 1WHERE slot = RAND() * 100;
(3) 用Sum(cnt)的方式得到总的访问数量
mysql>SELECT SUM(cnt) FROM hit_counter;
```


·         一种更为通用的做法是以“天”为单位对cnt进行维护，步骤如下
(1) 更改表结构


```
mysql>CREATE TABLE daily_hit_counter (

->  day date not null,

->  slot tinyint unsigned not null,

->  cnt int unsigned not null,

->  primary key(day, slot)

-> )ENGINE=InnoDB;
```

(2) 插入的时候，如果发现当天的某个slot已经存在，则对其cnt进行更行 


```
mysql>INSERT INTO daily_hit_counter(day, slot, cnt)

 ->  VALUES(CURRENT_DATE, RAND() * 100, 1)

->  ON DUPLICATE KEY UPDATE cnt= cnt + 1;
```

Summary, Cache,Counter表的使用会额外的表空间的开销。对于Summary, Cache表的内容可以使用Period脚本定期的进行清除或者是更新，对于Counter表可以定期的对已有的记录进行汇总，生成汇总记录后，只保留汇总记录。

- 加快alter table 操作的速度

alter table ：

将会直接修改.frm文件（存储表的列数据）

modify table:
所有的modify操作都将导致表重建。

change table




# 创建高性能的索引

## 索引基础

索引，在MySQL中又称为key.

### B-Tree索引
（从技术上说是B+Tree），==无需扫描全表,从索引根节点开始进行搜索==。
按照顺序存储数据，所以可以用来做order by ,group by 操作。
因为有序，所以也就会将所有的列值存储在一起。
因为索引中存储了实际的值，所以某些值只使用索引就能完成全部查询。

mysql中普遍使用B+Tree做索引，但在实现上又根据聚簇索引和非聚簇索引而不同。

#### b+树介绍

下面这张b+树的图片在很多地方可以看到，之所以在这里也选取这张，是因为觉得这张图片可以很好的诠释索引的查找过程。

![image](https://blog-10039692.file.myqcloud.com/1493034013688_4555_1493034014013.jpg)


如上图，是一颗b+树。浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。

真实的数据存在于叶子节点，即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

#### 查找过程

在上图中，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

#### 性质

#####  索引字段要尽量的小。
通过上面b+树的查找过程，或者通过真实的数据存在于叶子节点这个事实可知，IO次数取决于b+数的高度h。

假设当前数据表的数据量为N，每个磁盘块的数据项的数量是m，则树高h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；

而m = 磁盘块的大小/数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的；如果数据项占的空间越小，数据项的数量m越多，树的高度h越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。


##### 索引的最左匹配特性。

当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

### 哈希索引

- 只包含哈希值和行指针，而不去存储字段值，所以不可避免的去读取行（不过读取行也是挺快的，影响不大）。
- 不是按照索引值顺序存储的，所以无法排序。
- 不支持部分索引匹配查找，因为哈希值是通过索引列 的全部内容算出来的。例如key(A,B)，而查找只有A列，则无法使用索引。
- 只支持等值比较（包括=、in()、<=>），不支持任何范围查询。
- 如果存在哈希冲突，则需要遍历链表中所有的指针，进行逐个比较。如果冲突很多的话，维护索引，代价十分高昂。




### 索引的优点：

- 大大减少服务器需要扫描的数据量。
- 帮助服务器避免排序和临时表。
- 将随机IO变成顺序IO.

对于非常小的表，或许使用全表扫描更有效；
对于中大型的表，索引一般非常有效；
但对于超大型表，建立和使用索引的代价也会随之增长，这种情况可以使用分区技术。


## 创建高性能索引的策略


### 前缀索引

1. 对于字段比较长的列，可以使用前缀索引，但是应该注意尽量避免重复，可以使用`distinct col /count(col)`的比值作为**评估**指标，值越大说明重复率越少。


### 覆盖索引——一个索引包含所有需要查询的字段的值





一些情况查询情况下可能不会经过索引：

- 条件左边有表达式或者函数的话是不使用索引的。
- 





# 查询性能优化

- 索引列不使用表达式；
- 

sql执行过程：

```
客户端-->服务器-->解析，生成执行计划-->执行-->返回结果给客户端
```
 下面这幅图显示了查询的执行路径：

　　　① 客户端将查询发送到服务器；

　　　② 服务器检查查询缓存，如果找到了，就从缓存中返回结果，否则进行下一步。

　　　③ 服务器解析，预处理和优化查询，生成执行计划。

　　　④ 执行引擎调用存储引擎API执行查询。

　　　⑤ 服务器将结果发送回客户端。

![image](http://images2015.cnblogs.com/blog/856154/201612/856154-20161211152838616-669773850.png)

- 一般使用三种方式应用where条件：

    - 在索引中使用where条件来过滤不匹配的记录，这是在存储引擎层完成的。
    - 使用索引覆盖扫描（explain语句中的Extra列中出现Using index）来返回记录。直接从索引中过滤掉不需要的记录并返回命中得结果,这是mysql服务器层完成，但再无需回表查询记录；
    - 从数据表中返回数据，然后过滤掉不需要条件的记录（explain语句中的Extra列中出现Using where）。这是在mysql服务器层完成，mysql需要从数据表读取记录然后过滤；
    
## 重构查询的方式

### 一个复杂查询还是多个简单查询

平时我们更倡导用尽可能少的查询做尽可能多的事情，这样可以减少网络通信开销，能减少查询解析和优化的步骤，以及代码上似乎更优雅。
但是在MySql中，MySql被设计成可以很高效地连接和断开服务器，而且能很快地响应精简的查询。在现代网络下，MySql在一般的服务器上每秒钟可以处理100000个查询。因此，对于一些耗时的复杂查询，可以通过分解查询以得到更高的效率。


### 切分查询
分治思想，比如删除10000条数据，可以间隔暂停的去进行删除。。。


### 分解关联查询

简单说，就是对每个表进行一次单表查询，然后将结果在应用程序中进行关联。例如

![image](http://images.cnitblog.com/blog/625679/201412/221348336405350.png)

可以将其分解成下面查询来替代

![image](http://images.cnitblog.com/blog/625679/201412/221349053905384.png)

乍一看，这样做没有好处。事实上，有下面这些优势
让缓存效率更高。许多应用程序可以方便的缓存单表查询对应的结果对象。
将查询分解后，执行单个查询可以减少锁的竞争。
在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能，可扩展。
查询本身效率也会有所提升。在这个例子中，使用in代替关联查询，可以让mysql按照id顺序进行查询，这可能比随机的关联更高效。
可以减少冗余记录的查询。做关联查询时，可能需要重复访问一部分数据。从这点看，这样的重构还可能减少网络和内存的消耗。
实现了哈希关联，而不是使用mysql的嵌套循环关联。某些场景，哈希关联的效率要高很多。

- 让缓存的效率更高。许多应用程序可以方便地缓存单表查询对应的结果对象。例如，上面查询中的tag已经被缓存了，那么应用就可以跳过第一个查询。再例如，应用中已经缓存了ID为123、567、9098的内容，那么第三个查询的IN（）中就可以少几个ID。另外，对MySQL的查询缓存来说注6，如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。

- 将查询分解后，执行单个查询可以减少锁的竞争。

- 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。

- 查询本身效率也可能会有所提升。这个例子中，使用IN（）代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联要更高效。我们后续将详细介绍这点。

- 可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消艳。

- 更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。某些场景哈希关联的效率要高很多。

在很多场景下，通过重构查询将关联放到应用程序中将会更加高效，这样的场景有很多，比如：当应用能够方便地缓存单个查询的结果的时候、当可以将数据分布到不同的MySQL服务器上的时候、当能够使用IN（）的方式代替关联查询的时候、当查询中使用同一个数据表的时候。

## 查询执行的基础
MySQL客户端与服务器端是半双工的通信方式。

### 查询缓存

在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即使只有一个字节不同，那也不会匹配缓存结果，这种情况查询会进入下一个阶段的处理。
如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前MySQL会检查一次用户权限。这仍然是无须解析查询SQL语句的，因为==在查询缓存中已经存放了当前查询需要访问的表信息。如果权限没有问题，MySQL会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端。这种情况下，查询不会被解析，不用生成执行计划，不会被执行==。

缓存配置参数：

![image](http://images.cnitblog.com/i/572361/201407/061311427776870.png)

- query_cache_limit: MySQL能够缓存的最大结果,如果超出,则增加 Qcache_not_cached的值,并删除查询结果
- query_cache_min_res_unit: 分配内存块时的最小单位大小
- query_cache_size: 缓存使用的总内存空间大小,单位是字节,这个值必须是1024的整数倍,否则MySQL实际分配可能跟这个数值不同(感觉这个应该跟文件系统的blcok大小有关)
- query_cache_type: 是否打开缓存 OFF: 关闭 ON: 总是打开
- query_cache_wlock_invalidate: 如果某个数据表被锁住,是否仍然从缓存中返回数据,默认是OFF,表示仍然可以返回

### 查询优化处理

#### 语法解析器和预处理

首先，MySQL通过关键字将SQL语句进行解析，并生成一棵对应的“解析树”。MySQL解析器将使用MySQL语法规则验证和解析查询。例如，它将验证是否使用错误的关键字，或者使用关键字的顺序是否正确等，再或者它还会验证引号是否能前后正确的匹配。

预处理器则根据一些MySQL规则进一步检查解析树是否合法，例如，这里讲检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义。

下一步预处理器会验证权限，这通常很快，除非服务器上有非常多的权限设置。


## 查询优化器的局限性

### 关联子查询
in()加子查询，通常性能更糟，可以使用exists()来改写。


### UNION的限制




### 索引合并优化


### 并行执行


### 哈希关联



### 松散索引扫描

### 在同一个表上查询和更新


## 优化特定类型的查询

### count()
 
```
SELECT COUNT(*) FROM world.city WHERE ID > 5;
```
通过SHOW STATUS的结果可以看到该查询需要扫描4097行数据。如果将条件反转一下，先查找ID小于等于5的城市数，然后用总城市数一减就能得到同样的结果，却可以将扫描的行数减少到5行以内：

```
SELECT (SELECT COUNT(*) FROM world.city) - COUNT(*) FROM world.city WHERE ID <= 5;
```
如果在同一个查询中统计同一个列的不同值的数量，以减少查询的语句量。

```
mysql>SELECT SUM(IF(color = 'blue', 1, 0)) AS blue,SUM(IF(color = 'red', 1, 0)) AS red FROM items;
```

也可以使用COUNT()而不是SUM()实现同样的目的，只需要将满足条件设置为真，不满足条件设置为NULL即可：

```
mysql>SELECT COUNT(color = 'blue' OR NULL) AS blue,COUNT(color = 'red' OR NULL) AS red FROM items;
```
### 优化关联查询

- 确保on或者using子句上有索引，在创建索引的时候要考虑到关联的顺序，当表A和表B用列c关联的时候，如果优化器关联的顺序是B、A,就不需要在B上建立索引，没有用到的索引只会带来额外的负担，所以只需要在第二个表的相应列上建立索引。
- 确保Group by 和order by中的表达式只涉及到一个表中的列，这样才可能使用索引来优化这个过程。
- 当升级MySQL的时候需要注意，关联语法、运算符优先级等其他可能发生变化的地方，不同类型的关联可能会生成不同的结果。

### 优化子查询
尽可能使用关联查询吧，但并非绝对。

### 优化group by和distinct




### 优化limit分页


### 优化union

union 会在临时表上加上distinct,这会使整个表做唯一性检查，代价十分高昂。

### 静态查询分析

### 使用用户自定义变量















